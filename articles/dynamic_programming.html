<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>How Sequence Alignment Mirrors Classic String Matching | Shraddha Piparia</title>

  <!-- site-wide stylesheet and fonts -->
  <link rel="stylesheet" href="../style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
</head>

<body>
  <!-- ========= HEADER / NAV ========= -->
  <header class="header">
    <nav class="nav">
      <a class="logo" href="../index.html">SP</a>
      <button class="nav__toggle" aria-label="Toggle menu">&#9776;</button>
      <ul class="nav__menu">
        <li><a href="../propub.html">Select Publications</a></li>
        <li><a href="../awards.html">Awards</a></li>
        <li><a href="../bookshelf.html">Book&nbsp;Shelf</a></li>
        <li><a href="../articles.html" aria-current="page">Articles</a></li>
      </ul>
    </nav>
  </header>

  <!-- ========= ARTICLE ========= -->
  <main class="pagebox">
    <article class="post">
      <header class="post__header">
        <h1>How Sequence Alignment Mirrors Classic String Matching</h1>
        <p class="post__meta">
          Published&nbsp;<time datetime="2025-09-14">14&nbsp;September&nbsp;2025</time>
        </p>
      </header>

      <p>
        I used to think of sequence alignment as a specialist bioinformatics trick. But when I came across it first time, I realized the core ideas
        come straight from the classic string-matching problems we see in introductory algorithms. Dynamic programming,
        hashing, and suffix arrays all reappear — only slightly adapted for biological strings. For me, it felt like
        rediscovering something familiar in a new context.
      </p>

      <h2>From Exact Match to Similarity Score</h2>
      <p>
        In algorithms class, the question was simple: “Does pattern <em>P</em> occur in text <em>T</em>?” Methods like
        Knuth–Morris–Pratt or Boyer–Moore gave a yes/no answer plus the location. Biology rarely works that cleanly.
        Here, the question becomes, “How similar are these two strings if we allow edits?” A scoring scheme turns matches into
        points, mismatches into penalties, and gaps into bigger penalties. The output is not just an index, but an alignment and
        an overall similarity score.
      </p>

      <h2>Dynamic Programming as the Go-Getter</h2>
      <p>
        Needleman–Wunsch (global) and Smith–Waterman (local) extend the same Levenshtein-distance DP I first saw in CS courses.
        You build an (m + 1) × (n + 1) matrix, filling each cell by matching/mismatching (diagonal), deleting (up), or
        inserting (left). Smith–Waterman even adds a zero option for local resets. Time complexity is still <em>O</em>(mn), and
        a traceback from the top cell gives the aligned substrings. It’s the same DP pattern I learned years ago — now applied
        to DNA.
      </p>

      <h2>Scaling Up with Seed-and-Extend</h2>
      <p>
        Whole genomes make a full <em>O</em>(mn) DP far too heavy. That’s where BLAST feels clever: hash all fixed-length
        <em>k</em>-mers of the database, use exact hits as seeds, then run a narrow, banded Smith–Waterman around each seed.
        Most of the DP table is skipped, but strong alignments still appear quickly. It reminded me that smart shortcuts can
        keep old algorithms useful at scale.
      </p>

      <h2>Suffix Arrays and the FM-Index</h2>
      <p>
        Modern aligners go further, indexing the reference genome with a suffix array or FM-index. Candidate positions come in
        sub-linear time, and a limited DP extends each candidate. These index structures, which I first saw in Gusfield’s
        <em>Algorithms on Strings, Trees and Sequences</em>, now power billion-read pipelines. The continuity between theory
        and practice is striking.
      </p>

      <h2>Personal Takeaway</h2>
      <p>
        Sequence alignment is just approximate string matching at scale. Dynamic programming guarantees optimal alignments,
        while hashing and index structures make them practical on massive datasets. What struck me is how the Algorithms 101
        toolkit still underpins modern genomics — same principles, new alphabets, and much longer strings.
      </p>


      <p>
        For me, the rediscovery is this: dynamic programming isn’t just a classroom exercise, it’s a workhorse that keeps
        showing up in new domains. Seeing it power genome alignment reminded me that the basics we learn early on can become
        surprisingly practical — even decades later — when the problems get bigger and the context changes.
      </p>
    </article>
  </main>

  <!-- ========= JS: mobile-nav toggle ========= -->
  <script>
    const navToggle = document.querySelector('.nav__toggle');
    const navMenu  = document.querySelector('.nav__menu');
    navToggle.addEventListener('click', () => navMenu.classList.toggle('nav__menu--open'));
  </script>
</body>
</html>
